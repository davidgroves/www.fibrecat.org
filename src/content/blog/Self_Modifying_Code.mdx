---
title: Self Modifying Code
description: What is it, and can you use it today ?
pubDate: 19 September 2023
heroImage: /src/images/blog/italian_dragon.jpeg
heroCredit: Ravit Sages @ Unsplash
heroLink: https://unsplash.com/photos/gXyptwjk9aw
heroAltText: An italian statue of a dragon head
---

import { Image } from 'astro:assets';

## What is self modifying code.

It is like the name itself suggests, code which as part of what it is designed to do when you run it, modifies itself.
It is now considered an extreme optimisation for most development, and somethng that should in general be avoided. It used to be much
more common though, and is still something used in the embeded software industry where every byte of memory or every clock cycle
counts.

## A bad high level example.

Here is an example in Python that uses the [operator](https://docs.python.org/3/library/operator.html) standard library functions in
order to swap in an operator based on changes in the state of the program. I say this is a bad example as it isn't **really** an example of self
modifying code, as it the actual code run doesn't change, but it kind of looks like it does to the reader of the program.

This program will count up from 0 to 10, then count back down to 0 again and repeat this ad infinitum.

```python
import operator
import time

op = operator.add
i = 0

while True:
    print(i)
    time.sleep(0.2)
    i = op(i, 1)
    
    if i >= 10:
        op = operator.sub
    if i <= 0:
        op = operator.add
```

## A C example using function pointers.

This does the same thing in C, but it uses function pointers to swap between the increment and decrement functions.

```c
#include <stdio.h>
#include <unistd.h>

int i = 0;

int increment(int x) {
    return x + 1;
}

int decrement(int x) {
    return x - 1;
}

int main(int argc, char **argv) {
    /* Make a function pointer, starting out pointing at increment */
    int (*op)(int);
    op = increment;

    while (1) {
        printf("%d\n", i);
        usleep(200 * 1000);
        i = op(i);
        if (i >= 10) {
            op = decrement;
        }
        if (i <= 0) {
            op = increment;
        }
    }
}
```

Because we wrote this in C, we can prove that it is indeed not self modifying either by examining the assembly produced
while compiling it. This however is quite complex, even for a trivial example like this. Compiling this program to assembly with 
`$ gcc -O0 -S -o no_self_mod.asm no_self_mod.c` produces over 100 lines of AMD64 assembly. Expand the section below to view
this assembly if you care.

<details>
  <summary>the AMD64 assembly for the C program above</summary>
```
  	.file	"no_self_mod.c"
	.text
	.globl	i
	.bss
	.align 4
	.type	i, @object
	.size	i, 4
i:
	.zero	4
	.text
	.globl	increment
	.type	increment, @function
increment:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	increment, .-increment
	.globl	decrement
	.type	decrement, @function
decrement:
.LFB1:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	subl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE1:
	.size	decrement, .-decrement
	.section	.rodata
.LC0:
	.string	"%d\n"
	.text
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	subq	$32, %rsp
	movl	%edi, -20(%rbp)
	movq	%rsi, -32(%rbp)
	leaq	increment(%rip), %rax
	movq	%rax, -8(%rbp)
.L8:
	movl	i(%rip), %eax
	movl	%eax, %esi
	leaq	.LC0(%rip), %rax
	movq	%rax, %rdi
	movl	$0, %eax
	call	printf@PLT
	movl	$200000, %edi
	call	usleep@PLT
	movl	i(%rip), %eax
	movq	-8(%rbp), %rdx
	movl	%eax, %edi
	call	*%rdx
	movl	%eax, i(%rip)
	movl	i(%rip), %eax
	cmpl	$9, %eax
	jle	.L6
	leaq	decrement(%rip), %rax
	movq	%rax, -8(%rbp)
.L6:
	movl	i(%rip), %eax
	testl	%eax, %eax
	jg	.L8
	leaq	increment(%rip), %rax
	movq	%rax, -8(%rbp)
	jmp	.L8
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	"GCC"
	.section	.note.GNU-stack,"",@progbits
	.section	.note.gnu.property,"a"
	.align 8
	.long	1f - 0f
	.long	4f - 1f
	.long	5
0:
	.string	"GNU"
1:
	.align 8
	.long	0xc0000002
	.long	3f - 2f
2:
	.long	0x3
3:
	.align 8
4:
```
</details>

## Some self modifying code.











